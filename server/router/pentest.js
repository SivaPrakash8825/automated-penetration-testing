const amqp = require("amqplib/callback_api");
const urlvalid = require("valid-url");
const { exec } = require("child_process");
const requestmodel = require("../schema/request");
const express = require("express");
const router = express.Router();
const ZapClient = require("zaproxy");
const zapOptions = {
  apiKey: "rki1o56ofug84lcnt9d76gths2",
  proxy: {
    host: "127.0.0.1",
    port: 8080,
  },
};

const zaproxy = new ZapClient(zapOptions);
let indicator;
function initializeSocket(io) {
  io.on("connection", (socket) => {
    socket.on("join_team", (userid) => {
      socket.join(userid);
    });
  });
  indicator = io;
}

const AddUserRequest = async (req, res, next) => {
  const { userId, url, urlId } = req.body;
  try {
    const result = await requestmodel.create({
      userid: userId,
      url: url,
      status: "scheduled",
      urlId: urlId,
    });
    if (result) {
      next();
    }
  } catch (error) {
    console.log(error);
    res.status(401).json({ error: error.message });
  }
};

amqp.connect("amqp://localhost", function (error0, connection) {
  if (error0) {
    throw error0;
  }
  connection.createChannel(function (error1, channel) {
    if (error1) {
      throw error1;
    }
    const queue = "user_requests";
    channel.assertQueue(queue, {
      durable: false,
    });
    channel.prefetch(1);
    router.post("/scan", AddUserRequest, (req, res) => {
      const { userId, url, urlId } = req.body;

      channel.sendToQueue(
        queue,
        Buffer.from(JSON.stringify({ userId, url, urlId }))
      );
      res.status(200).send("scheduled");
    });

    channel.consume(
      queue,
      async function (msg) {
        const { userId, url, urlId } = JSON.parse(msg.content.toString());

        indicator
          .to(userId)
          .emit("status", { urlId: urlId, status: "inprogress" });
        await requestmodel.findOneAndUpdate(
          { urlId: urlId },
          { status: "inprogress" }
        );
        if (urlvalid.isUri(url)) {
          const [result1, result2] = await Promise.all([
            forNmap(url),
            forZap(url),
          ]);
          console.log(result1);
          console.log(result2);
          if (result1 != "error" || result2 != "error") {
            await requestmodel.findOneAndUpdate(
              { urlId: urlId },
              {
                status: "completed",
                zap: JSON.stringify(result2),
                nmap: JSON.stringify(result1),
              }
            );
            indicator.emit("status", {
              urlId: urlId,
              status: "completed",
              nmapstatus: result1 != "error" ? true : false,
              zapstatus: result2 != "error" ? true : false,
            });
          } else {
            await requestmodel.findOneAndUpdate(
              { urlId: urlId },
              {
                status: "error",
                zap: JSON.stringify(result2),
                nmap: JSON.stringify(result1),
                nmapstatus: false,
                zapstatus: false,
              }
            );
            indicator.emit("status", { urlId: urlId, status: "error" });
          }
          channel.ack(msg);
        } else {
          await requestmodel.findOneAndUpdate(
            { urlId: urlId },
            { status: "error" }
          );
          indicator
            .to(userId)
            .emit("status", { urlId: urlId, status: "error" });
          channel.ack(msg);
        }
      },
      {
        noAck: false,
      }
    );
  });
});

const forNmap = (mainurl) => {
  return new Promise((resolve, reject) => {
    const url = mainurl;
    const domain = new URL(url).hostname.replace("www.", "");
    exec(`nmap  ${domain}`, (error1, stdout1, stderr1) => {
      if (stderr1 || error1) {
        return resolve("error");
      }
      const lines = stdout1.split("\n").filter((line) => line.trim() !== "");
      const headingsIndex = lines.findIndex((line) => line.includes("PORT"));
      const headings = lines[headingsIndex].trim().split(/\s+/);
      const data = [];
      for (let i = headingsIndex + 1; i < lines.length - 1; i++) {
        const values = lines[i].trim().split(/\s+/);
        data.push(values);
      }
      data.unshift(headings);
      return resolve(data);
    });
  });
};

const forZap = (url) => {
  const vulnerabilitiesByRisk = {};
  return new Promise(async (resolve, reject) => {
    try {
      const response = await zaproxy.spider.scan({
        url: url,
      });
      let spiderStatus, activestatus;
      do {
        spiderStatus = await zaproxy.spider.status(response.scan);
        // console.log();
      } while (spiderStatus.status !== "100");
      const activeScanResponse = await zaproxy.ascan.scan({
        url: url,
      });
      if (activeScanResponse.scan) {
        do {
          activestatus = await zaproxy.ascan.status(activeScanResponse.scan);
        } while (activestatus.status !== "100");
        if (activestatus.status === "100") {
          const alerts = (
            await zaproxy.core.alerts({
              baseurl: url,
            })
          ).alerts;

          if (alerts) {
            alerts.forEach((alert) => {
              if (!vulnerabilitiesByRisk[alert.risk]) {
                vulnerabilitiesByRisk[alert.risk] = 0;
              }
              vulnerabilitiesByRisk[alert.risk]++;
              const detailsToReproduce = alerts.map((alert) => ({
                name: alert.name,
                riskrate: alert.risk,
                confidence: alert.confidence,
                vulsummar: alert.description,
                solution: alert.solution,
                reference: alert.reference,
              }));
              vulnerabilitiesByRisk["details"] = detailsToReproduce;
            });
          } else {
            return resolve(vulnerabilitiesByRisk);
          }
        }
        return resolve(vulnerabilitiesByRisk);
      } else {
        return resolve("error");
      }
    } catch (error) {
      resolve("error");
    }
  });
};

module.exports = { router, initializeSocket };
