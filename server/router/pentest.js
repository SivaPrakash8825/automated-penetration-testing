const amqp = require("amqplib/callback_api");
const urlvalid = require("valid-url");
const { exec } = require("child_process");
const requestmodel = require("../schema/request");
const express = require("express");
const router = express.Router();
let indicator;
function initializeSocket(io) {
  io.on("connection", (socket) => {
    socket.on("join_team", (userid) => {
      socket.join(userid);
    });
  });
  indicator = io;
}

const AddUserRequest = async (req, res, next) => {
  const { userId, url, urlId } = req.body;
  try {
    const result = await requestmodel.create({
      userid: userId,
      url: url,
      status: "scheduled",
      urlId: urlId,
    });
    if (result) {
      next();
    }
  } catch (error) {
    console.log(error);
    res.status(401).json({ error: error.message });
  }
};

amqp.connect("amqp://localhost", function (error0, connection) {
  if (error0) {
    throw error0;
  }
  connection.createChannel(function (error1, channel) {
    if (error1) {
      throw error1;
    }
    const queue = "user_requests";
    channel.assertQueue(queue, {
      durable: false,
    });
    channel.prefetch(1);
    router.post("/scan", AddUserRequest, (req, res) => {
      const { userId, url, urlId } = req.body;

      channel.sendToQueue(
        queue,
        Buffer.from(JSON.stringify({ userId, url, urlId }))
      );
      res.status(200).send("scheduled");
    });

    channel.consume(
      queue,
      async function (msg) {
        const { userId, url, urlId } = JSON.parse(msg.content.toString());

        indicator
          .to(userId)
          .emit("status", { urlId: urlId, status: "inprogress" });
        await requestmodel.findOneAndUpdate(
          { urlId: urlId },
          { status: "inprogress" }
        );
        if (urlvalid.isUri(url)) {
          const [result1, result2] = await Promise.all([
            forNmap(url),
            forZap(url),
          ]);

          if (result1 && result2) {
            await requestmodel.findOneAndUpdate(
              { urlId: urlId },
              { status: "completed", zap: result2, nmap: result1 }
            );
            indicator.emit("status", { urlId: urlId, status: "completed" });
            channel.ack(msg);
          }
        } else {
          await requestmodel.findOneAndUpdate(
            { urlId: urlId },
            { status: "error" }
          );
          indicator
            .to(userId)
            .emit("status", { urlId: urlId, status: "error" });
          channel.ack(msg);
        }
      },
      {
        noAck: false,
      }
    );
  });
});

function extractIPv4Addresses(dnsResponse) {
  const ipv4Addresses = [];

  for (const line of dnsResponse) {
    const matches = line.match(/\b(?:\d{1,3}\.){3}\d{1,3}\b/);
    if (matches) {
      ipv4Addresses.push(matches[0]);
    }
  }
  return ipv4Addresses;
}

const forNmap = async (mainurl) => {
  let result;
  await new Promise((resolve, reject) => {
    const url = mainurl;
    const domain = new URL(url).hostname.replace("www.", "");

    console.log(domain);
    exec(`nmap  ${domain}`, (error1, stdout1, stderr1) => {
      if (error1) {
        console.error("Error:", error1);
        return res.status(500).send("Error performing port scan");
      }
      if (stderr1) {
        console.error("stderr:", stderr1);
      }
      const lines = stdout1.split("\n").filter((line) => line.trim() !== "");

      const headingsIndex = lines.findIndex((line) => line.includes("PORT"));

      // Extract headings
      const headings = lines[headingsIndex].trim().split(/\s+/);

      // Array to store the extracted data
      const data = [];

      // Iterate over the lines starting from the line after headings
      for (let i = headingsIndex + 1; i < lines.length - 1; i++) {
        const values = lines[i].trim().split(/\s+/);
        data.push(values);
      }
      // Prepend headings to the data array
      data.unshift(headings);
      // Print the extracted data
      result = data;
      console.log(data);
      resolve();
      // Iterate over the remaining lines to extract values
    });
  });
  return result;
};

const forZap = async (url) => {
  const vulnerabilitiesByRisk = {};
  await new Promise(async (resolve, reject) => {
    try {
      const response = await zaproxy.spider.scan({
        url: url,
      });
      let spiderStatus, activestatus;
      do {
        spiderStatus = await zaproxy.spider.status(response.scan);
        // console.log();
      } while (spiderStatus.status !== "100");
      const activeScanResponse = await zaproxy.ascan.scan({
        url: url,
      });
      do {
        activestatus = await zaproxy.ascan.status(activeScanResponse.scan);
      } while (activestatus.status !== "100");
      if (activestatus.status === "100") {
        const alerts = (
          await zaproxy.core.alerts({
            baseurl: url,
          })
        ).alerts;

        alerts.forEach((alert) => {
          if (!vulnerabilitiesByRisk[alert.risk]) {
            vulnerabilitiesByRisk[alert.risk] = 0;
          }
          vulnerabilitiesByRisk[alert.risk]++;
          const detailsToReproduce = alerts.map((alert) => ({
            name: alert.name,
            riskrate: alert.risk,
            confidence: alert.confidence,
            vulsummar: alert.description,
            solution: alert.solution,
            reference: alert.reference,
          }));
          vulnerabilitiesByRisk["details"] = detailsToReproduce;
        });
      }
      // const jsonResponse = JSON.stringify(response);
      // fs.writeFile("report.json", jsonResponse, (err) => {
      //   if (err) throw err;
      //   console.log("Report saved successfully!");
      // });
      resolve();
    } catch (error) {
      console.error("Error:", error);
    }
  });
  return vulnerabilitiesByRisk;
};

module.exports = { router, initializeSocket };
