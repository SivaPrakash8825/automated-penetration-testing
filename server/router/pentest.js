const amqp = require("amqplib/callback_api");
const urlvalid = require("valid-url");
const { exec } = require("child_process");
const requestmodel = require("../schema/request");
const { checkConnection } = require("../db/db");
const express = require("express");
const router = express.Router();
let indicator;
function initializeSocket(io) {
  io.on("connection", (socket) => {
    socket.on("join_team", (userid) => {
      socket.join(userid);
    });
  });
  indicator = io;
}
checkConnection();

const AddUserRequest = async (req, res, next) => {
  const { userId, url, urlId } = req.body;
  try {
    const result = await requestmodel.create({
      userid: userId,
      url: url,
      status: "scheduled",
      urlId: urlId,
    });
    if (result) {
      next();
    }
  } catch (error) {
    console.log(error);
    res.status(401).json({ error: error.message });
  }
};

amqp.connect("amqp://localhost", function (error0, connection) {
  if (error0) {
    throw error0;
  }
  connection.createChannel(function (error1, channel) {
    if (error1) {
      throw error1;
    }
    const queue = "user_requests";
    channel.assertQueue(queue, {
      durable: false,
    });
    channel.prefetch(1);
    router.post("/scan", AddUserRequest, (req, res) => {
      const { userId, url, urlId } = req.body;

      channel.sendToQueue(
        queue,
        Buffer.from(JSON.stringify({ userId, url, urlId }))
      );
      res.status(200).send("scheduled");
    });

    channel.consume(
      queue,
      async function (msg) {
        const { userId, url, urlId } = JSON.parse(msg.content.toString());

        indicator
          .to(userId)
          .emit("status", { urlId: urlId, status: "inprogress" });
        await requestmodel.findOneAndUpdate(
          { urlId: urlId },
          { status: "inprogress" }
        );
        if (urlvalid.isUri(url)) {
          const [result1, result2] = await Promise.all([
            forNmap(url),
            forZap(url),
          ]);
          if (result1 && result2) {
            await requestmodel.findOneAndUpdate(
              { urlId: urlId },
              { status: "completed", zap: result2, nmap: result1 }
            );
            indicator.emit("status", { urlId: urlId, status: "completed" });
            channel.ack(msg);
          }
        } else {
          await requestmodel.findOneAndUpdate(
            { urlId: urlId },
            { status: "error" }
          );
          indicator
            .to(userId)
            .emit("status", { urlId: urlId, status: "error" });
          channel.ack(msg);
        }
      },
      {
        noAck: false,
      }
    );
  });
});

function extractIPv4Addresses(dnsResponse) {
  const ipv4Addresses = [];

  for (const line of dnsResponse) {
    const matches = line.match(/\b(?:\d{1,3}\.){3}\d{1,3}\b/);
    if (matches) {
      ipv4Addresses.push(matches[0]);
    }
  }
  return ipv4Addresses;
}

const forNmap = async (url) => {
  let lines2;
  await new Promise((resolve, reject) => {
    exec(`nslookup ${url}`, (error, stdout, stderr) => {
      if (error) {
        console.error(error);
        return res.status(500).send("Error performing DNS lookup");
      }

      if (stderr) {
        console.error(stderr);
      }

      const lines = stdout.split("\n").filter((line) => line.trim() !== "");
      const ipAddress = extractIPv4Addresses(lines);
      console.log("adsf" + ipAddress);
      exec(
        `nmap -sV -oG - ${ipAddress[ipAddress.length - 1]}`,
        (error1, stdout1, stderr1) => {
          if (error1) {
            console.error("Error:", error1);
            return res.status(500).send("Error performing port scan");
          }

          if (stderr1) {
            console.error("stderr:", stderr1);
          }

          lines2 = stdout1.split("\n").filter((line) => line.trim() !== "");

          const openPorts = [];
          for (const line of lines2) {
            let parts = line.split("\t");
            if (parts[0].startsWith("Host")) {
              for (const value of parts) {
                if (value.trim().startsWith("Status")) {
                  console.log(value.trim());
                }
                if (value.trim().startsWith("Ports")) {
                  const arr = value.split(",");
                  console.log(arr.length);
                }
              }
            }
          }

          // Generating report
          // const report = {
          //   numberOfVulnerablePorts: openPorts.length,
          //   detailedReport: openPorts.map((port) => ({
          //     portNumber: port.portNumber,
          //     protocol: port.protocol,
          //     service: port.service,
          //     recommendedAction: "Recommendation goes here", // Add your recommendation here
          //   })),
          // };

          resolve();
        }
      );
    });
  });
  return lines2;
};

const forZap = async (url) => {
  const vulnerabilitiesByRisk = {};
  await new Promise(async (resolve, reject) => {
    try {
      const response = await zaproxy.spider.scan({
        url: url,
      });
      let spiderStatus, activestatus;
      do {
        spiderStatus = await zaproxy.spider.status(response.scan);
        // console.log();
      } while (spiderStatus.status !== "100");
      const activeScanResponse = await zaproxy.ascan.scan({
        url: url,
      });
      do {
        activestatus = await zaproxy.ascan.status(activeScanResponse.scan);
      } while (activestatus.status !== "100");
      if (activestatus.status === "100") {
        const alerts = (
          await zaproxy.core.alerts({
            baseurl: url,
          })
        ).alerts;

        alerts.forEach((alert) => {
          if (!vulnerabilitiesByRisk[alert.risk]) {
            vulnerabilitiesByRisk[alert.risk] = 0;
          }
          vulnerabilitiesByRisk[alert.risk]++;
          const detailsToReproduce = alerts.map((alert) => ({
            name: alert.name,
            riskrate: alert.risk,
            confidence: alert.confidence,
            vulsummar: alert.description,
            solution: alert.solution,
            reference: alert.reference,
          }));
          vulnerabilitiesByRisk["details"] = detailsToReproduce;
        });
      }
      // const jsonResponse = JSON.stringify(response);
      // fs.writeFile("report.json", jsonResponse, (err) => {
      //   if (err) throw err;
      //   console.log("Report saved successfully!");
      // });
      resolve();
    } catch (error) {
      console.error("Error:", error);
    }
  });
  return vulnerabilitiesByRisk;
};

module.exports = { router, initializeSocket };
